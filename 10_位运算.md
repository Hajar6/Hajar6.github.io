### 位运算相关知识
* 有符号数，正（首位0）、负（首位1）
* 二进制中的5中运算：与（&）、或（|）、异或（^，相异为1）、左移（<<）、右移（>>）
* 左移（m<<n）：将m左移n位，左侧的舍去，右侧补0。
* 右移（m>>n）：将m左移n位，右侧舍去，左侧补0/符号位（若为有符号数）。
* 二进制补码：正数（不变）、负数（除符号位外，其余按位取反，然后再加1）

### 问题10：二进制中1的个数
1. 问题描述：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示
例如：输入把9表示为二进制是1001，有2个1，所以输出2。

2. 可能陷入死循环的解法
思想：从n的2进制形式的最右边开始判断是不是1。（跟1做“与&”）
但是：若输入时负数会陷入死循环，因为负数右移时，在最高位补得是1，那么会有无数个1了。
```
public class Solution {
    */
    //-------------可能陷入死循环的解法---------------------
    public static int NumberOf1_CanNotUse(int n) {
        int count = 0;
        while (n != 0) {
            if ((n & 1) == 1) {
                count++;
            }
            //把n的2进制形式往右推一位
            n = n >> 1;
        }
        return count;
    }
  }
```
3. 正解
思想：将待比较的数‘1’左移（其实后来就不是1了），和n的每位进行位与，来判断1的个数。
可以避免原数右移，可能增加1的情况。
```
    private static int NumberOf1_low(int n) {
        int count = 0;
        int flag = 1;
        while (flag != 0) {
            if ((n & flag) != 0) {
                count++;
            }
            flag = flag << 1;
        }
        return count;
    }
```
4. 最优解
思想：把一个整数减去1，再和原整数做“与”，会把该整数最右边一个1变为0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。基于这种思路，我们可以：
```
# -*- coding:utf-8 -*-
class Solution:
    def NumberOf1(self, n):
        # write code here
        count = 0
        if n<0:
            # 把负号去掉，0xFFFFFFFF代表一个16进制数，转为2进制为：32个1.
            n=n&0xFFFFFFFF
        while n:
            n = n&(n-1)
            count+= 1
        return count
}
```
分析一下代码： 这段小小的代码，很是巧妙。
举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。
这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.
那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。

